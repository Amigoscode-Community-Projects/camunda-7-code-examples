# Dynamic Tenant Per Engine 
Spring Boot Application using [Camunda](http://docs.camunda.org) to create a multi-tenant system by configuring a BPMN engine per-tenant and attaching to the same database. 

Important bit is the same app can be deployed with different environment configuration automatically creating a new tenant.

This project has been generated by the Maven archetype
[camunda-archetype-spring-boot-demo-7.11.1](https://docs.camunda.org/manual/latest/user-guide/process-applications/maven-archetypes/).

## Show me the important parts!
**Custom Engine Configuration setup to define the engine name and deployment based on environment variable PROCESS_ENGINE_NAME.**

```java
@Bean
  public SpringProcessEngineConfiguration processEngineConfiguration() throws IOException {
    SpringProcessEngineConfiguration config = new SpringProcessEngineConfiguration();

    System.out.println("\n\n ########### ProcessEngineName ==: "+processEngineName);
    config.setProcessEngineName(processEngineName);
    
    config.setDataSource(dataSource);
    config.setDatabaseSchemaUpdate("true");
    
    config.setTransactionManager(transactionManager());

    config.setHistory(historyLevel);

    config.setJobExecutorActivate(true);
    config.setMetricsEnabled(false);

    // deploy all processes from folder 'processes/tenant-<n>'
    Resource[] resources = resourceLoader.getResources("classpath:/processes/"+processEngineName.trim()+"/*.bpmn");
    config.setDeploymentResources(resources);
    config.setDeploymentTenantId(processEngineName);
    
    return config;
  }
```

This config will boot-strap a new engine for each tenant defined and connect to the database. The app uses environment variables to define the engine and the tenants. 

The primary environment variables.

- PROCESS_ENGINE_NAME
- DATABASE_URL

Other environment conigs can be added using springs app config properties.

## How does it work?

The config will auto-deploy any processes in the resource directory based on the tenant defined resources path.

```resource[] resources = resourceloader.getresources("classpath:/processes/"+processenginename.trim()+"/*.bpmn");
Resource[] resources = resourceLoader.getResources("classpath:/processes/"+processEngineName.trim()+"/*.bpmn");
```

This will resolve to the following path in the project

```
src/main/resources/processes/tenant-<n>
```


## How to use it?

**Add a new tenant as needed**

```yaml
camunda_tenant_1:
    build:
      context: ./dynamo
    ports:
      - "8080:8080"
    environment:
      PROCESS_ENGINE_NAME: tenant-1

camunda_tenant_2:
  build:
      context: ./dynamo
    ports:
      - "9090:8080"
    environment:
      PROCESS_ENGINE_NAME: tenant-2
```



#### *** Start The Tenants with Docker Compose ***

1. Add tenants to the docker-compose file as described above

2. define a new directory in your project based on the tenant name provided in the PROCESS_ENGINE_NAME environment variable. 

   ``` bash
   src/main/resources/processes/tenant-<n>
   ```

3. build the jar

```bash
mvn clean package
```

3. Run docker-compose to start the tenant with a shared DB

``` bash
docker-compose up
```

#### *** Run with Maven Spring Boot Plugin ***

1. Run the process application without docker:

```bash
mvn clean spring-boot:run -DPROCESS_ENGINE_NAME=tenant-1
```

#### *** To reset workflow engine state ***
1. do this between restarts to reset processes
```bash
rm camunda-db.mv.db
```

#### Unit Test

You can run the JUnit test [InMemoryH2Test](src/main/resources/archetype-resources/src/test/java/ProcessTest.java) in your IDE or using:
```bash
mvn clean test
```

### Running the application
You can also build and run the process application with Spring Boot.

#### Manually
1. Build the application using:
```bash
mvn clean package
```
2. Run the *.jar file from the `target` directory using:
```bash
java -jar target/Camunda Spring Boot Application.jar
```

For a faster 1-click (re-)deployment see the alternatives below.

#### Your Java IDE
1. Run the project as a Java application in your IDE using CamundaApplication as the main class.

### Run and Inspect with Tasklist and Cockpit

Go to the server:port defined in your docker-compose for each tenant.

http://localhost:8080/ for tenant 1

http://localhost:9090/ for tenant 2

Once you deployed the application you can run it using
[Camunda Tasklist](http://docs.camunda.org/latest/guides/user-guide/#tasklist)
and inspect it using
[Camunda Cockpit](http://docs.camunda.org/latest/guides/user-guide/#cockpit).

## Environment Restrictions
Built and tested against Camunda BPM version 7.11.0.

## Known Limitations

## License
[Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0).

<!-- HTML snippet for index page
  <tr>
    <td><img src="snippets/poc-camunda-mindstrong/src/main/resources/process.png" width="100"></td>
    <td><a href="snippets/poc-camunda-mindstrong">Camunda Spring Boot Application</a></td>
    <td>Spring Boot Application using [Camunda](http://docs.camunda.org).</td>
  </tr>
-->
<!-- Tweet
New @Camunda example: Camunda Spring Boot Application - Spring Boot Application using [Camunda](http://docs.camunda.org). https://github.com/camunda-consulting/code/tree/master/snippets/poc-camunda-mindstrong
-->
